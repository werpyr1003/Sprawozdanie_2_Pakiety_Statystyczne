---
title: "Sprawozdanie 2"
format: html
editor: visual
---

```{r}
library('tidyverse')
library(DescTools)
```

```{r}
# Parametry
n <- 5             # Liczba prób
p0 <- 0.1          # Hipoteza zerowa
alpha <- 0.05      # Poziom istotności
p_values <- seq(0, 1, length.out = 100)  # Wartości p do testowania
n_sim <- 500     # Liczba symulacji Monte Carlo

```

```{r}
# Funkcja obliczająca moc testu dla danego p
power_function <- function(p, method) {
  rejections <- replicate(n_sim, {
    # Losowanie próbki z rozkładu dwumianowego
    x <- rbinom(1, n, p)
    
    # Obliczanie przedziału ufności
    ci <- BinomCI(x, n, conf.level = 1 - alpha, method = method)
    
    # Sprawdzanie, czy p0 nie mieści się w przedziale
    if (p0 < ci[1] || p0 > ci[2]) {
      return(1)  # Odrzucamy H0
    } else {
      return(0)  # Nie odrzucamy H0
    }
  })
  mean(rejections)  # Średni odsetek odrzuceń
}
```

```{r}
# Obliczanie funkcji mocy dla każdej metody
power_wilson <- sapply(p_values, power_function, method = "wilson")
power_clopper <- sapply(p_values, power_function, method = "exact")
power_jeffreys <- sapply(p_values, power_function, method = "jeffreys")

```

```{r}
# Wykresy
plot(p_values, power_wilson, type = "l", col = "blue", lwd = 2, ylim = c(0, 1),
     xlab = "p", ylab = "Moc testu", main = "Funkcja mocy testów", 
     las = 1)
lines(p_values, power_clopper, col = "red", lwd = 2)
lines(p_values, power_jeffreys, col = "green", lwd = 2)
abline(v = p0, lty = 2, col = "black")  # Linia dla p0
legend("bottomright", legend = c("Wilson", "Clopper-Pearson", "Jeffreys"),
       col = c("blue", "red", "green"), lwd = 2)
```

```{r}
# Parametry
n <- 5                # Liczba prób
p0 <- 0.1             # Wartość z hipotezy zerowej
alpha <- 0.05         # Poziom istotności
p_values <- seq(0, 1, length.out = 100)  # Wartości p do testowania
n_sim <- 10000        # Liczba symulacji Monte Carlo

# Funkcja obliczająca moc testu dla danego p
power_function <- function(p, method) {
  rejections <- replicate(n_sim, {
    # Losowanie próbki z rozkładu dwumianowego
    x <- rbinom(1, n, p)
    
    # Obliczanie przedziału ufności
    ci <- BinomCI(x, n, conf.level = 1 - alpha, method = method)[, c("lwr.ci", "upr.ci")]
    
    # Sprawdzanie, czy p0 nie mieści się w przedziale
    if (p0 < ci[1] || p0 > ci[2]) {
      return(1)  # Odrzucamy H0
    } else {
      return(0)  # Nie odrzucamy H0
    }
  })
  mean(rejections)  # Średni odsetek odrzuceń
}

# Obliczanie funkcji mocy dla każdej metody
power_wilson <- sapply(p_values, power_function, method = "wilson")
#power_clopper <- sapply(p_values, power_function, method = "clopper-pearson")
#power_jeffreys <- sapply(p_values, power_function, method = "jeffreys")

# Wykres dla metody Wilsona
plot(p_values, power_wilson, type = "l", col = "blue", lwd = 2, ylim = c(0, 1),
     xlab = "p", ylab = "Moc testu", main = "Funkcja mocy - Wilson")
abline(v = p0, lty = 2, col = "black")  # Linia pionowa dla p0
legend("bottomright", legend = c("Wilson"), col = "blue", lwd = 2)



```
